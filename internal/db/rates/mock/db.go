// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mockratesdb

import (
	"context"
	ratesdb "itspay/internal/db/rates"
	"itspay/internal/entity"
	"sync"
)

// Ensure, that DBMock does implement ratesdb.DB.
// If this is not the case, regenerate this file with moq.
var _ ratesdb.DB = &DBMock{}

// DBMock is a mock implementation of ratesdb.DB.
//
//	func TestSomethingThatUsesDB(t *testing.T) {
//
//		// make and configure a mocked ratesdb.DB
//		mockedDB := &DBMock{
//			SaveRateFunc: func(ctx context.Context, rate *entity.Rate) error {
//				panic("mock out the SaveRate method")
//			},
//		}
//
//		// use mockedDB in code that requires ratesdb.DB
//		// and then make assertions.
//
//	}
type DBMock struct {
	// SaveRateFunc mocks the SaveRate method.
	SaveRateFunc func(ctx context.Context, rate *entity.Rate) error

	// calls tracks calls to the methods.
	calls struct {
		// SaveRate holds details about calls to the SaveRate method.
		SaveRate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Rate is the rate argument value.
			Rate *entity.Rate
		}
	}
	lockSaveRate sync.RWMutex
}

// SaveRate calls SaveRateFunc.
func (mock *DBMock) SaveRate(ctx context.Context, rate *entity.Rate) error {
	if mock.SaveRateFunc == nil {
		panic("DBMock.SaveRateFunc: method is nil but DB.SaveRate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Rate *entity.Rate
	}{
		Ctx:  ctx,
		Rate: rate,
	}
	mock.lockSaveRate.Lock()
	mock.calls.SaveRate = append(mock.calls.SaveRate, callInfo)
	mock.lockSaveRate.Unlock()
	return mock.SaveRateFunc(ctx, rate)
}

// SaveRateCalls gets all the calls that were made to SaveRate.
// Check the length with:
//
//	len(mockedDB.SaveRateCalls())
func (mock *DBMock) SaveRateCalls() []struct {
	Ctx  context.Context
	Rate *entity.Rate
} {
	var calls []struct {
		Ctx  context.Context
		Rate *entity.Rate
	}
	mock.lockSaveRate.RLock()
	calls = mock.calls.SaveRate
	mock.lockSaveRate.RUnlock()
	return calls
}
